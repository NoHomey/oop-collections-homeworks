//--------------------------------------------
// NAME: Ivo Stratev
// CLASS: XIb
// NUMBER: 16
// PROBLEM: #1
// FILE NAME: string.cc
// FILE PURPOSE:
// Make an implementation of the abstract class String.
//---------------------------------------------
#include <iostream> // In order to use the standart input, outupt and error streams of c++.
#include <string.h> // In order to use strcpy, strcmp, strlen and all other strings related functions defined for c.
#include <stdexcept> // In order to throw standart exceptions such as the base class exception and the class out_of_range
// wich inherites from exception.
using namespace std; // Using std in order to avoid writing std:: before cout, out_of_range
// and all other things defined under the std scope.

class String {
	size_t capacity_; // A private member used to hold the size of memory block of chars
	// currrently alocated for the coresponding instance.
	size_t size_; // A private member used to indicate the current size of the coresponding instance.
	char* data_; // A private member that stores the String value in the heap (the dynamic memory)
	// wich allows the value to change it's size.
	friend ostream& operator<<(ostream&, const String&); // Define that operator<< defined outside of the class
	// to have an access to the private members.
public:
	//--------------------------------------------
	// FUNCTION: String
	// Inicializate new blank instance of the class by inicializating capacity_ with capacity,
	// size_ with 0 and allocates new memory block of chars, capacity for data_.
	// Also used as default constructor of the class with the default value of the argument equal 1
	// so memory blocks of the class can be created wich requires a default constructor to be done.
	// PARAMETERS:
	// capacity
	// capacity is used to determinate the memory block size.
	//----------------------------------------------
	String(size_t capacity = 1) 
    : capacity_(capacity), size_(0), data_(new char[capacity])	// Inicializating capacity_ with capacity,
    // size_ with 0 and allocates new memory block of chars for data_ capacity long.
	{}
	//--------------------------------------------
	// FUNCTION: String (overloaded constructor)
	// Inicializates new instance of the class with size_ = length of the passed string,
	// capacity_ with one more then size_, data_ with new memory block of chars, capacity_ long and 
	// copying the string value to data_.
	// PARAMETERS:
	// string
	// string is used for inicializating new instance of the class wich holds string value.
	//----------------------------------------------
	String(const char* string) {
		size_ = strlen(string);	// Inicializating size_ with the size of the argument string.
		capacity_ = size_ + 1;	// Inicializating capacity_ with size_ plus 1.
		data_ = new char[capacity_];	//A llocates new memory block of chars for data_.
		strcpy(data_, string);	// Inicializating data_ by coping the argument string value into data_.
	}
	//--------------------------------------------
	// FUNCTION: String (overloaded constructor wich is also the copy-constructor of the class)
	// Defining valid copy-constructor for the class, because it's using dinamyc memory to store the value
	// and if it's not a valid one when inicializating new instance of the class with allready created one
	// both will point the same memory block.
	// PARAMETERS:
	// string
	// A read-only reference to an object of the class wich is going to be used
	// to inicializate new instance as a copy of the passed object.
	//----------------------------------------------
	String(const String& string)
	: capacity_(string.capacity_), size_(string.size_), data_(new char[string.capacity_]) {	// Inicializates capacity_ and size_
	// with  the passed object capacity_ and size_ and allocates capacity_ long memory block of chars for data_.
		strcpy(data_, string.data_); // Copying the passed instance of the class value (data_) to newly created one data_.
	}
	//--------------------------------------------
	// FUNCTION: ~String (destructor)
	// Used to destory an instance of the class when is no longer needed or goes out of scope by deallocating
	// he memory used for data_ because the destructor generated by the compilator isn't valid since ddynamic memory
	// is used for storing data_.
	// PARAMETERS:
	// None.
	//----------------------------------------------
	~String() {
		delete [] data_; // Dealocating the memory used to store the instance value into data_. 
	}
	//--------------------------------------------
	// FUNCTION: size
	// Returns size_ value.
	// PARAMETERS:
	// None.
	//----------------------------------------------
	size_t size() const {
		return size_; // Returning size_.
	}
	//--------------------------------------------
	// FUNCTION: length
	// Alias for size(), returns size_ value.
	// PARAMETERS:
	// None.
	//----------------------------------------------
	size_t length() const {
		return size(); // Returning size_. 
	}
	//--------------------------------------------
	// FUNCTION: capacity
	// Returns capacity_ value.
	// PARAMETERS:
	// None.
	//----------------------------------------------
	size_t capacity() const {
		return capacity_; // Returning capacity_.
	}
	//--------------------------------------------
	// FUNCTION: empty
	// Returns true if the insance of the class is empty (with size_ that equals 0) else returns false.
	// PARAMETERS:
	// None.
	//----------------------------------------------
	bool empty() const {
		return (size_ == 0); // Returning does size_ equals 0.
	}
	//--------------------------------------------
	// FUNCTION: clear
	// Clears the instance by setting size_ to 0, capacity_ to 1 and making data_ point to new dynamic char.
	// PARAMETERS:
	// None.
	//----------------------------------------------
	void clear() {
		delete [] data_; // Deallocating the memory block used for storing data_.
		size_ = 0;  // Resets size_.
		capacity_ = 1;  // Setting capacity_ to one.
		data_ = new char;   // Allocate new char for data_.
	}
	//--------------------------------------------
	// FUNCTION: operator[]
	// Return the value with ofset the argument index from data_.
	// PARAMETERS:
	// index
	// index is used to return the element on that index.
	//----------------------------------------------
	char& operator[](size_t index) {
		return data_[index];    // Returns the value on index index.
	}
	//--------------------------------------------
	// FUNCTION: at
	// Return the value with ofset the argument index from data_ if inex is less than size_.
	// PARAMETERS:
	// index
	// index is used to return the element on that index.
	//----------------------------------------------
	char& at(size_t index) {
        if(index >= size_)  // If index isn't valid index throws standart out_of_range exception.
        	throw out_of_range("Invalid Index!");   // Throws standart out_of_range exception.
        return operator[](index); // If the program control isn't redirected to out_of_range returns data_[index].
	}
	//--------------------------------------------
	// FUNCTION: operator==
	// Returns true if the instance in both sides are equal else return false.
	// PARAMETERS:
	// string.
	// string is used for the compersion.
	//----------------------------------------------
	bool operator==(const String& string) const {
		return !(strcmp(data_, string.data_)); // strcmp() returns postive, negative or 0 value inverting it
		// will result in 0, 1 or 0 wich is false, true, false and this result will be returned.
	}
	//--------------------------------------------
	// FUNCTION: operator!=
	// Returns true if the instance in both sides aren't equal else return false.
	// PARAMETERS:
	// string.
	// string is used for the compersion.
	//----------------------------------------------
	bool operator!=(const String& string) const{
		return !(operator==(string));   // Returns the result of performing operator== by inverting it wich will
		// result in true, false or true.
	}
	//--------------------------------------------
	// FUNCTION: operator>
	// Returns true if the instance in the left side is greater than the one on right else returns false.
	// PARAMETERS:
	// string.
	// string is used for the compersion.
	//----------------------------------------------
	bool operator>(const String& string) const{
		return (strcmp(data_, string.data_) > 0); // Returns does the object on left is greter than the one on right.
	}
		//--------------------------------------------
	// FUNCTION: operator<
	// Returns true if the instance in the left side is less than the one on right else returns false.
	// PARAMETERS:
	// string.
	// string is used for the compersion.
	//----------------------------------------------
	bool operator<(const String& string) const{
		return (strcmp(data_, string.data_) < 0); // Returns does the object on left is less than the one on right.
	}
	//--------------------------------------------
	// FUNCTION: operator>=
	// Returns true if the instance in the left side is greater or equal than the one on right else returns false.
	// PARAMETERS:
	// string.
	// string is used for the compersion.
	//----------------------------------------------
	bool operator>=(const String& string) const{
		return !(operator<(string)); // Reurns the result of performing operator< by inverting it.
	}
	//--------------------------------------------
	// FUNCTION: operator<=
	// Returns true if the instance in the left side is less or equal than the one on right else returns false.
	// PARAMETERS:
	// string.
	// string is used for the compersion.
	//----------------------------------------------
	bool operator<=(const String& string) const{
		return !(operator>(string)); // Reurns the result of performing operator> by inverting it.
	}
	//--------------------------------------------
	// FUNCTION: operator=
	// If the operand on the left side is defirent than the one on the rigth assigns
	// the value of the one on the rigth to the one on the left because the class is using
	// dynamic memory block to store it's value and the operator generated by the compilator isn't valid.
	// PARAMETERS:
	// string.
	// string is used for the assigment.
	//----------------------------------------------
	String& operator=(const String& string) {
		if(this != &string) {  //If the operant on the left is deferent from the one on the rigth
		// (avoiding string = string) simply because if this check inst' perfore the data_ will be
		// dealocated and afther a try for copying htat same data_ will be made and an error will ocure.
			delete [] data_; // Deallocating the meomory block that stores the value of the class in data_.
			size_ = string.size_; // Copying the argument's size_.
			capacity_ = string.capacity_; // Alse copying it's capacity_ since a direct copy is requested.
			data_ = new char[capacity_]; // Allocating new memory block for data_ capacity_ long.
			strcpy(data_, string.data_); // Coppying the values for the argument to the current instance.
		}
		return *this; // And returning reference to the current object.
	}
	//--------------------------------------------
	// FUNCTION: ensure_capacity
	// Checks if the requested increase of the block is avalible or not and if isn't it makes it.
	// number
    // number is used to request the increasment.
	//----------------------------------------------
	void ensure_capacity(size_t number = 1) {
		int check = capacity_ - (size_ + number); // Performing a calcolation to see how much space isn't avalible.
		if(check < 0) { // Performing a check to see if some space isn't avalible.
			char* old_data = data_; // Copy the starting adress of data_.
			capacity_ += (check *= -1); // Increase capacity with the space  that isn't avalible.
			data_ = new char[capacity_]; // Allocating new momory block for data_ capacity_ long.
			strcpy(data_, old_data); // Saving the old value again to data_.
			delete [] old_data; // Deallocating the old memory block used to store data_.
		}
	}
	//--------------------------------------------
	// FUNCTION: append
	// Performs a concatenation betwean the current instance and the one thats passed
	// by appending the argument at the end of the object for wich the method is called.
	// string
    // string is the value that needs to be concatenated with the current instance.
	//----------------------------------------------
	String& append(const String& string) {
		ensure_capacity(string.size_); // Calling ensure_capacity() with the size of 
		// the argument to check if that much space is avalible for use in data_
		// and if not ensure_capacity() will add as much as needed.
		strcat(data_, string.data_); // Concatenating the two stings by performing strcat() wich requires 
		// the size of the dynamic bufer to have need free space with the size of the passed argument.
		size_ += string.size_; // Increasing size_ with the size_ of the provaded argument.
		return *this; // And returning a reference to the current object.
	}
	//--------------------------------------------
	// FUNCTION: operator+=
	// Performs a concatenation betwean the current instance and the one thats passed
	// by appending the argument at the end of the object for wich the method is called.
	// string
    // string is the value that needs to be concatenated with the current instance.
	//----------------------------------------------
	String& operator+=(const String& string) {
		return append(string); // Performing append() no need to write the same code again we can simply reuse it.
	}
	//--------------------------------------------
	// FUNCTION: push_back
	// Adding a symbol at the end of the trace of data_ by creating new instance and appending it.
	// PARAMETERS:
	// symbol
	// symbol is the char that's gonna be added to the current object.
	//----------------------------------------------
	void push_back(const char& symbol) {
		char* tmp = new char[2]; // Allocating new momory block 2 chars long so new instance can be carated and concatenaed.
		tmp[0] = symbol; // Saving the symbol to the first element of tmp.
		tmp[1] = '\0'; // Terminating the "string" tmp.
		String string(tmp); // Crating new instance of the class wich is gona store the symbol passsed as new object of the class
		append(string); // And reusing append once again.
		delete [] tmp; // Deallocating the temp bufer tmp.
	}
	//--------------------------------------------
	// FUNCTION: operator+
	// Substracing two instances of the class and crating new one that holds the value of the substraction.
	// PARAMETERS:
	// string
	// stirng is the second operand of the substraction.
	//----------------------------------------------
	String operator+(const String& string) {
		String tmp(*this); // Creating new instance that holds the current value.
		return String(tmp += string); // and returning new instance wich's value is the
		// concatenation of the two operands.
	}
	class Iterator {
		char* position_; // A pointer that's gonna points to a single elemnt of an instance.
	public:
		//--------------------------------------------
		// FUNCTION: Iterator (constructor and default constructor of the class)
		// Inicializates where to point position_ default value is NULL ptr or 0.
		// PARAMETERS:
		// position
		// posiiton is used as the position to where position_ needs to point to.
		//----------------------------------------------
		Iterator(char* position = 0)
		: position_(position) // Inicializating position_
		{}
		//--------------------------------------------
		// FUNCTION: operator++ (prefix)
		// Makes position_ point to one afther where currently is pointing to.
		// PARAMETERS:
		// None.
		//----------------------------------------------
		Iterator operator++() {
			position_++; // Increment position_.
			return *this; // and returning the current object afther the repostition.
		}
		//--------------------------------------------
		// FUNCTION: operator++ (postfix)
		// Makes position_ point to one afther where currently is pointing to but returning 
		// the current position by memory copying the object.
		// PARAMETERS:
		// None (a fictive one just so the compilator knows wich one operator to predifine).
		//----------------------------------------------
		Iterator operator++(int) {
			Iterator result(position_); // Memory copying the current instance.
			position_++; // Increment position_.
			return result; // Returning the copy.
		}
		//--------------------------------------------
		// FUNCTION: operator==
		// Compeare two instances and returns does they are equal.
		// PARAMETERS:
		// iterator
		// iterator is the object with wich the comparearsion is made.
		//----------------------------------------------
		bool operator==(const Iterator& iterator) const{
			return (position_ == iterator.position_); // Returning does the operand on left is equal to 
			// the one on rigth.
		}
		//--------------------------------------------
		// FUNCTION: operator!=
		// Compear two instances and returns does they aren't equal.
		// PARAMETERS:
		// iterator
		// iterator is the object with wich the comparearsion is made.
		//----------------------------------------------
		bool operator!=(const Iterator& iterator) const{
			return !(operator==(iterator)); // Returning does the operand on left isn't equal to 
			// the one on rigth by inverting the result from performing operator==.
		}
		//--------------------------------------------
		// FUNCTION: operator*
		// Returns the value at wich the instance is pointing to at an instance of String.
		// PARAMETERS:
		// None
		//----------------------------------------------
		char& operator*() {
			return *position_; // Return the value by dereferencing position_.
		}
	};
	//--------------------------------------------
	// FUNCTION: begin
	// Returns and instance of Iterator pointing to the first element.
	// PARAMETERS:
	// None.
	//----------------------------------------------
	Iterator begin() const{
		return Iterator(data_); // Create new instance of Iterator that points to the first element.
	}
	//--------------------------------------------
	// FUNCTION: begin
	// Returns and instance of Iterator pointing to one afther the last element.
	// PARAMETERS:
	// None.
	//----------------------------------------------
	Iterator end() const{
		return Iterator(data_ + size_); // Create new instance of Iterator that points one past the last element.
	}
};

//--------------------------------------------
// FUNCTION: operator<<
// Defines a proper operator<< (for aoutput) for the class.
// PARAMETERS:
// out and string
// out is object of type ostream where the instance is outputed and string is the instance thats outputed.
//----------------------------------------------
ostream& operator<<(ostream& out, const String& string) {
	for(size_t i = 0; i < string.size_;++i) // For each element from string.
		out << string.data_[i]; // Output the value.
	return out; // Return reference to the same object (stream) where stirng was outputed.
}

//--------------------------------------------
// FUNCTION: main
// Tests the implementation of the String class and alse tells the compilator and runtime from where to start.
// PARAMETERS:
// argc and argv
// argc is the number of the arguments provaided once the program is ran and argv are the arguments 
// if less than three are provided Segmentation fault is outputed. 
//----------------------------------------------
int main(int argc, char** argv) {
	String str1(argv[1]); // Creating new instance of String with value second argument.
	String str2(argv[2]); // Creating new instance of String with value third argument.
	cout << "string 1: <" << str1 << '>' << endl; // Printing the first instance.
	cout << "string 2: <" << str2 << '>' << endl; // Printing the second instance.
	cout << "string 1 length: " << str1.length() << endl; // Outputing the length of the first object of type String.
	cout << "string 2 length: " << str2.length() << endl; // Outputing the length of the second object of type String.
	size_t count = 0; // Defining a counter for spaces called count and inicilaizating it with 0.
	for(String::Iterator it = str1.begin(); it != str1.end();++it) { // Iterating from the beging of str1 upto it's end.
		if(*it == ' ') count++; // Counting how much spaces str1 contains.
	}
	cout << "string 1 spaces: " << count << endl; // outputing the result of sapces countment.
	count = 0; // Reseting count.
	for(String::Iterator it = str2.begin(); it != str2.end();++it) { // Iterating from the beging of str2 upto it's end.
		if(*it == ' ') count++; // Counting how much spaces str2 contains.
	}
	cout << "string 2 spaces: " << count << endl; // outputing the result of sapces countment.
	cout << '<'; // This and the next 8 lines are used to output wich strng of str1 and str2 is bigger.
	if(str1 > str2) {
		cout << str1 << "> is greater than <" << str2;
	} else {
		if(str1 < str2)
			cout << str2 << "> is greater than <" << str1;
		else cout << str2 << "> is equal to <" << str1;
	}
	cout << '>' << endl;
	str1.push_back('!'); // Adding '!' at the end of str1.
	cout << "string 1: <" << str1 << '>' << endl; // Outputing str1.
	str2.push_back('!'); // Adding '!' at the end of str2.
	cout << "string 2: <" << str2 << '>' << endl; // Outputing str2.
	String str = str1 + str2; // Creating new instance of String that holds the result from substracing str1 and str2.
	cout << "concatenation: <" << str << '>' << endl; // Outputing the result string.
	cout << "concatenation length: " << str.length() << endl; // Outputing the length of the result string.
	count = 0; // Reseting count.
	for(String::Iterator it = str.begin(); it != str.end();++it) { // Iterating from the beging of str upto it's end.
		if(*it == ' ') count++; // Counting how much spaces str contains.
	}
	cout << "concatenation spaces: " << count << endl; // Outputing the result for spaces.
	return 0; // Retuning 0 to indicate that main() finished succesfuly.
}
